# Software_Engineering_Finalexam
소프트웨어공학 기말고사 정리입니다.
임계영역(Critical Path)를 구하는 문제 출제
[사이버국가고시센터](https://www.gosi.kr/)
## 형상 관리
```
소프트웨어 시스템의 새로운 버전은 다음의 경우에 작성
1. 상이한 기계나 운영체제를 위해
2. 상이한 기능의 제공
3. 특정 사용자 요구사항에 맞추기 위해

형상관리는 진화하는 소프트웨어 시스템과 관련됨
1. 시스템 변경은 팀 단위의 활동
2. 형상 관리는 시스템에 대한 변경에 포함된 비용과 노력을 관리하는 것이 목적임

진화하는 소프트웨어 제품을 관리하기 위한 절차와 표준을 개발하고 적용하는 것을 포함
형상 관리는 더욱 일반적인 품질 경영 프로세스의 일부일 수 있음
형상 관리에 릴리스될 때, 소프트웨어 시스템은 때때로 추가적인 개발의 출발점으로써
기준점(baselines)이라고 부름

형상관리 표준

형상 관리는 조직 내에 적용되는 표준의 집합에 항상 기초
표준은 항목들이 어떻게 식별되고, 변경이 어떻게 제어되며, 새로운 버전들이 어떻게 관리되는지를 정의
표준은 외부의 형상 관리 표준(예 : 형상관리를 위한 IEEE표준)에 기초할 수 있음
일부 기존의 표준들은 폭포수 프로세스 모델에 기초하므로, 진화적인 개발을 위한 새로운 형상 관리 표준이 필요
```

## 빈번한 시스템 구축
```
프로세스의 초기에 컴포넌트 간의 상호작용을 통해 나오는 문제를 찾기가 더 쉬움
이것은 단위 테스트를 통해 장려됨
발견되고 수정된 문제들을 추적하기 위한 엄격한 변경 관리 프로세스가 요구
```

## 형상 관리 활동
```
형상 식별(Identification) : 형상 관리를 할 항목을 식별하는 것
형상 제어(Control) : 형상에 대한 변경요청이 있을 경우, 변경 여부와 활동을 통제하는 것
형상 상태보고(Status Accounting) : 형상 변경에 대한 내용을 기록하고 보고하는 것
형상 감사(Audit) : 형상 항목이 요구사항에 맞도록 잘 변경되었는지를 확인하는 것
```

## CCB 형상 통제 위원회(Configuration Control Board)

## 형상 관리(CM)
```
CM이 필요한 이유는 버전에 어떤 변경과 컴포넌트 버전에 포함되었는 지를 놓치기 쉽다.
CM은 상이한 개발자에 의해 수행된 변경을 관리하기 위해 팀 프로젝트에 필수
```

## 애자일 개발과 CM
```
하루에도 몇 번씩 컴포넌트와 시스템이 변경되는 애자일 개발은 CM 툴을 사용하지 않고는 불가능

컴포넌트의 최종 버전은 공유 프로젝트 저장소에 보관되며 개발자들은 이를 자신의 작업공간에 복사

개발자들은 코드를 변경한 다음 테스팅을 위해 시스템 구축 도구를 사용하여 자신의 컴퓨터에 새로운 시스템을 생성

일단 변경사항이 만족되면 수정된 구성요소를 프로젝트 리포지토리에 반
```

## 멀티 버전 시스템
```
대형 시스템의 경우, 단 하나의 '동작' 버전이 있는 것은 아님
서로 다른 개발 단계에서 시스템의 여러 버전이 항상 존재
상이한 시스템 버전들의 개발에 여러 팀이 관련됨
```

## 큰 번호(버전번호) 작은 번호(릴리스 번호)
```
개발할 때 수정하는 건 버전번호 -> 사용자에게 릴리즈되는 번호가 다르다.
```
## 코드라인과 베이스 라인
```
코드라인은 소스 코드의 일련의 버전들이고, 나중 버전들은 이전의 버전들로부터 유도됨

일반적으로 코드라인은 시스템의 컴포넌트들에 적용되므로 각 컴포넌트의 상이한 버전들이 존재

베이스라인은 특정 시스템의 정의

따라서 시스템에 포함되는 컴포넌트 버전들을 명시하고 사용된 라이브러리, 설정 파일 등을 명시함

베이스라인은 시스템의 특정 버전에 어떤 컴포넌트들이 포함되어야 하는 지를 정의한 형상 언어를 사용하여 명시될 수 있음

베이스 라인은 완성된 시스템의 특정 버전을 종종 다시 생성해야 하므로 중요
예를 들어, 어떤 고객이 사용하고 있는 시스템에서 오류를 발견하고 신고하면, 수정 작업을 위해 고객에게 인도되었던 시스템 버전을 다시 생

코드라인이 모여서 베이스라인
베이스라인이 모여서 메인라인
```
## 버전 관리
```
버전 관리는 코드라인과 베이스라인을 관리하는 프로세스다.
버전관리는 소프트웨어 컴포넌트들과 이 컴포넌트들이 사용되는 시스템의
여러 버전들을 추적 관리하는 프로세스
또한 이런 버전들에 대해 여러 개발자들이 수행하는 변경 작업이 서로 방해받지 않도록 하는 것을 포함
```
## 버전 관리 시스템
```
버전 관리(VC) 시스템은 컴포넌트의 여러 버전들을 식별,저장,접근 제어를 함.
현대 버전 관리 시스템의 두가지 유형

중앙집중 시스템 : Subversion
분산 시스템 : Git

버전과 릴리즈를 식별
변경 이력 기록
독립적인 개발
프로젝트 지원
저장소 관리
```
## 공용 저장소와 개인 작업공간
```
컴포넌트를 수정할 때, 개발자는 컴포넌트를 저장소에서 자신의 작업공간으로 복사(check-out)하고, 이 복사본에 대해 작업을 수행
개발자가 변경 작업을 완료하면, 변경된 컴포넌트들을 저장소로 반납(check-in)

여러 사람이 동시에 한 컴포넌트에 대해 작업하면, 각각은 저장소로부터 컴포넌트에 대해 체크아웃해야 함, 만약 어떤 컴포넌트가 체크아웃되었으면, VC 시스템은 해당 컴포넌트의 체크아웃을 원하는 사용자에게 이미 누군가에 의해 체크아웃되었음을 경고
```
## 분산 버전 관리
```
마스터 저장소가 개발팀에 의해 생성되는 코드를 유지하는 서버에 생성
필요한 파일들의 단순한 체크아웃 대신 개발자는 프로젝트 저장소의 사본을 생성하여 자신의 컴퓨터에 설치
개발자는 자신의 컴퓨터에 설치된 개인 저장소에서 필요한 파일 작업을 수행하고, 새로운 버전을 유지
변경이 끝나면 commit을 통해 이 변경이 반영되어 개인이 저장소가 변경, 그 다음 개발자는 이 변경들이 프로젝트 저장소에 반영되도록 push

분산 버전관리의 장점
1. 저장소에 대해 백업 매커니즘을 제공
2. 네트워크 연결이 되지 않는 상황에서도 개발자들은 변경이 반영되도록 할 수 있음
3. 프로젝트 작업 지원 : 개발자들은 자신의 컴퓨터에서 전체 시스템을 컴파일하고 테스트할 수 있으며, 자신이 수행한 변경에 대한 테스트를 할 수 있음
```
## 오픈 소스 개발
```
분산 버전 관리는 오픈 소스 개발에 필수적
개발자들은 자신의 컴퓨터에 있는 개인 저장소뿐만 아니라 공용 서버 저장소도 유지하여, 자신들이 변경한 컴포넌트들의 새 버전들을 서버 저장소로 내보냄(push) 그 다음 언제 이런 변경들을 최종 프로젝트 저장소로 가져올지 pull 결정하는 것은 오픈 시스템의 관리자가 결정

코드라인은 분기되고 합병될 수 있다.
```
## 시스템 구축
```
시스템을 구성하는 소스파일이나 데이터 파일, 라이브러리들을 컴파일하고 링크해서 실행 가능한 하나의 주 시스템을 만드는 것이 시스템 구축이라고 한다.

자동화된 빌드 시스템(컴파일러, 구축 스크립트들)
```
## 개발, 구축, 타겟 플랫폼
```
개발할 때 사용하는 -> 개발 시스템
버전관리 및 빌드서버 -> 구축 시스템
타겟 시스템
```
## 지속적인 통합
```
그림을 보고 무엇을 뜻하는 가? Continueous Integretion : 지속적인 통합 
대표적인 도구로 Jenkins이 있습니다.

개발하다가 변경사항을 반영하고 구축하고 테스트한다음에 새로운 베이스라인으로 반영한다.
```
## 소스 코드와 목적 코드의 링킹
```
자바 파일(.java) 컴파일하면 클래스 파일이 나오는데 이 클래스 파일이
자바 파일이 수정된 자바 파일의 클래스 파일은 아니기 때문에 클래스 파일이
어떤 자바 파일의 클래스 파일인지를 알기 위해서 타임스탬프를 사용할 수 있다.
타임 스탬프(언제 컴파일되었는지)가 맞는 것이 자바 - Time Based identification

자바 - 클래스 파일마다 다른 체크섬을 비교한다. - Cheksum Based identification
```

## 변경 관리 프로세스
```
변경하고 나서 얻는 결과를 예측하고 비용이 많이 들어가는 변경은 줄이고 
어떤 컴포넌트가 변경되었는지를 추적하는 프로세스가 변경 관리 프로세스이다.

Change Request 변경 요청을 하면 변경을 체크하고 변경이 유효하면 변경을 등록,
소프트웨어 수정을 하는 개발 및 테스트 진행하고 변경을 적용한다.

형상관리 위원회 CCB에서 최종적으로 베이스라인에 반영할지를 결정한다.
```
## 릴리스 계획에 영향을 미치는 요인들
```
경쟁 : 대중 시장 소프트웨어인 경우 시장 점유 확보를 위해 릴리스
마케팅 요구 :  마케팅 부서의 요구에 맞춰서 릴리스
플랫폼 변화 : 운영체제 플랫폼의 새로운 버전의 릴리스
시스템의 기술적 변화 : 시스템의 심각한 결함이 보고
```
## 보안성 공학
```
애플리케이션 시스템의 보안을 명세화하고 설계하는 데 초점을 맞추어 보안

사용자 및 허가 관리, 시스템 소프트웨어 배치와 유지보수, 공격 감시, 탐지 및 복구
```
## 보안 위험 관리
```
위험 평가 -> 시스템 획득 결정 이전에 시작하여 개발 프로세스 동안 계속되는 단계적 프로세스이다.

위험 평가의 단계적 프로세스 : 사전 위험 평가, 생명주기 동안의 위험 평가

사전 위험 평가 : 전체 시스템에 관한 보안 요구사항을 유도하는 것
사전 위험 평가의 필수 단계

자산 식별 -> 보호할 필요성이 있는 시스템 자산인가?

생명주기 위험 평가 : 보호되어야 할 필요성이 있는 것에 대한 더욱 상세한 정보를 알게되고
시스템의 취약점에 관해 알게 된다. 시스템 아키텍처와 데이터 구성에 관한 지식을 활용하면서
기술 선택에 관련된 취약점의 예시를 들 수 있다는 것이 사전 위험 평가와의 중요한 차이점이다.
```
## 보안을 위한 설계
```
1. 아키텍처 설계 : 어떤 아키텍처 설계 결정이 시스템의 보안에 영향을 미치는가?
2. 좋은 실무 관행(설계 지침) : 안전한 시스템을 설계할 때 받아들일 만한 좋은 실무 관행은 무엇인가?
3. 배치를 위한 설계 : 시스템이 사용을 위해 배치될 때 어떤 취약점이 있는가?

보안을 유지하는 시스템 아키텍처 설계 시 고려사항
보호 (protection) : 시스템이 어떻게 구성되어야 중요한 자산이 외부 공격에 보호될 수 있는 가?
분산 (distribution) : 시스템 자산이 어떻게 분산되어야 공격의 영향을 최소화할 수 있는 가?

계층 아키텍처 <- 중요한 자산을 낮은 수준에 두고 그 주위에 다양한 보호 계층을 두는 계층아키텍처가 
보안에 적합한 아키텍처이다.

데이터 보호가 중요한 요구사항이라면 서버에 구축된 보호 메커니즘을 가진 클라이언트-서버 아키텍처를 사용한다.

서비스 거부 공격이 주요위험이라면 애플리케이션 시스템을 위한 분산 객체 아키텍처를 사용할 수 있다.

정답 -> 계층, 클라이언터-서버, 분산 객체 아키텍처

계층마다 요구하는 수준의 보호를 두어 계층화된 보호 아키텍처를 둔다.
```
